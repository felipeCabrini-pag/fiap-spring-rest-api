| **Aspecto**                           | **RestTemplate**                                                                                         | **OpenFeign**                                                                                                            | **Rest Client (Spring 6)**                                                                                                  |
|---------------------------------------|-----------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|
| **Estilo de Programação**             | - Imperativo: uso direto de métodos como `getForObject()`, `exchange()`, etc.                             | - Declarativo: define-se uma interface com `@FeignClient` e anotações (ex.: `@GetMapping`, `@PostMapping`)                | - Declarativo: usa interfaces com anotações nativas como `@HttpExchange`, `@GetExchange`, `@PostExchange`                       |
| **Dependências**                      | - Parte do Spring Web; sem dependências extras                                                          | - Requer a dependência `spring-cloud-starter-openfeign`                                                                    | - Nativo do Spring 6 / Spring Boot 3; sem dependências externas                                                                   |
| **Síncrono vs. Reativo**              | - Síncrono (bloqueante)                                                                                   | - Síncrono (bloqueante) por padrão; pode ser adaptado para padrões assíncronos com técnicas adicionais                       | - Pode ser usado de forma síncrona ou reativa, dependendo dos métodos declarados e da configuração do subjacente WebClient          |
| **Boilerplate**                       | - Requer mais código para configurar cada chamada, gerenciamento manual de headers, erros e timeouts     | - Menor boilerplate, pois a implementação é gerada automaticamente a partir das interfaces e anotações                      | - Menos boilerplate que o WebClient puro; permite definir endpoints de forma declarativa sem a necessidade de escrever lógica repetitiva |
| **Integração com Spring Cloud**       | - Pode ser integrado, mas exige configurações extras para service discovery e load balancing              | - Excelente integração: suporta nativamente service discovery (Eureka), load balancing (Ribbon ou Spring Cloud LoadBalancer) e circuit breaker (Resilience4j/Hystrix) | - Integração nativa limitada; pode ser combinado com outras soluções para discovery e resiliência se necessário                    |
| **Configuração de Erros/Timeouts**    | - Configurável via `ResponseErrorHandler` e `ClientHttpRequestFactory` (ex.: `HttpComponentsClientHttpRequestFactory`) | - Configurável via propriedades e customização com `ErrorDecoder`                                                          | - Configurável através do WebClient subjacente (usando métodos como `onStatus()` e propriedades de timeout do Reactor)                |
| **Uso de DTOs (POJOs)**               | - Requer mapeamento manual ou uso de conversores para transformar JSON em objetos Java                     | - Facilita o uso de DTOs: os métodos da interface declaram os tipos de entrada/saída                                      | - Similar ao Feign: permite declaração clara de DTOs usando anotações na interface                                                    |
| **Resiliência (Retries, Circuit Breaker)** | - Requer integração manual com bibliotecas como Resilience4j ou Hystrix                                    | - Fácil de integrar com circuit breakers e fallback, geralmente com configuração mínima no ecossistema Spring Cloud         | - Pode ser combinado com Resilience4j ou outras bibliotecas para implementar resiliência; a configuração depende do WebClient utilizado |
| **Cenários de Uso**                   | - Projetos legados ou casos onde chamadas bloqueantes são aceitáveis; uso pontual de APIs externas         | - Ideal para ambientes de microsserviços que se beneficiam de uma abordagem declarativa e integração nativa com Spring Cloud | - Recomendado para novos projetos que utilizam Spring 6, onde se deseja um cliente HTTP nativo, com menor boilerplate e potencial reativo |
| **Pontos Fortes**                     | - Simples, amplamente conhecido e sem dependências adicionais                                            | - Menos código repetitivo, excelente integração com o ecossistema Spring Cloud e facilidade na manutenção                   | - Nativo do Spring 6, permite um mapeamento declarativo simples, com flexibilidade para uso síncrono ou reativo                      |
| **Pontos Fracos**                     | - Bloqueante, pode resultar em maior consumo de threads e código verboso                                  | - Depende de uma lib externa (OpenFeign) e é bloqueante por padrão, a menos que adaptado para métodos assíncronos              | - Relativamente novo no ecossistema; funcionalidades avançadas (como service discovery nativo) podem estar em desenvolvimento         |